# goit-algo-hw-09

Жадібний алгоритм працює швидше для випадків, де оптимальне рішення можна досягнути без необхідності переглядати попередні рішення, оскільки він просто вибирає найбільші доступні номінали монет, що дозволяє мінімізувати кількість операцій. Але жадібний алгоритм не завжди гарантує найменшу кількість монет.

Алгоритм динамічного програмування вимагає більше часу та обчислювальних ресурсів, оскільки він розглядає всі можливі комбінації монет для кожної частини суми до досягнення загальної суми. Цей метод гарантує знаходження мінімальної кількості монет для будь-якої суми, але може бути менш ефективним за часом виконання, особливо при великих сумах.

Для великих сум алгоритм динамічного програмування продовжує мати перевагу у точності рішення (мінімізація кількості монет), але його часова складність та використання пам'яті зростають, що може стати проблемою для дуже великих сум або обмежених умов виконання. З іншого боку, жадібний алгоритм зберігає свою високу швидкість виконання та низьке використання пам'яті незалежно від суми, хоча і ризикує не завжди знаходити оптимальне рішення за кількістю монет.

## Порівняння ефективності   

| Function                          |         123 |       1234 |       12345 |      1234567 |
|:----------------------------------|------------:|-----------:|------------:|-------------:|
| Функція жадібного алгоритму       | 1.49161e-05 | 1.2083e-05 | 9.58377e-06 |  1.19579e-05 |
| Функція динамічного програмування | 0.00110483  | 0.0173172  | 0.135035    | 12.8206      |


Як видно з разультатів дослідження, Функція динамічного програмування суттєво виграє в швидкості порівняно з Функцією жадібного алгоритму.


## О велике (Big O Notation)   

Жадібний алгоритм має часову складність O(n), де n — кількість різних номіналів монет. Це тому, що в найгіршому випадку вам доведеться перевірити кожен номінал один раз.
Алгоритм динамічного програмування має часову складність O(Wn), де W — сума, що потрібно видати, а n — кількість різних номіналів монет. 

Висновок: Жадібний алгоритм є більш ефективним за часом виконання та використанням пам'яті при умові, що він забезпечує оптимальне рішення для заданих номіналів монет. Алгоритм динамічного програмування забезпечує точність у знаходженні мінімальної кількості монет для будь-якої суми, але вимагає більше часу та пам'яті, особливо при роботі з великими сумами.